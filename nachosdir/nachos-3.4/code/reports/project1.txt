Project 1 Report for Group 7

Exercise 1 - Dillon Archer 6224872

For the first part of this exercise, I modified Threadtest1() to take n number of integers by 
implementing a for loop. This allowed the function to fork 'n' number of Threads 
which call SimpleThread(). Next, I modified SimpleThread to share a variable called
SharedVariable between all of the forked and original threads. Once the for loop within
SimpleThread is completed, SharedVariable is stored within val and displayed using a printf statment
to show what value each thread sees within the function call. 

Before the implementation of the semaphores, when the for loop runs, each thread would overwrite
the increment done by the previous thread on the global variable when it yields the processor 
to the next thread. This resulted in a situation where in a case when there is 'n' 
number of threads, the global variable would contain a value that is 'n/5'.

After implementing the semaphores, the global variable is properly synchronized across all threads.
First, the Semaphore value is incremented by one at the start of the ThreadTest1 function to indicate
that the processor is available to be utilized by the threads. Then, as each thread runs its for loop,
it acquires the processor by calling the Semaphore s.P() function. Once it is done updating the local, 
variable, the thread releases the processor by incrementing the value of the semaphore. If a processor
happens to acquire the processor before the semaphore is released, then the current thread is put
to sleep by the semaphore before it is allowed to increment the global variable.  

Before the  implementation of random interrupts, this procedure correctly increments the 
variable 'n*5' times.


Nagarjun Tumkur Sharathkumar - 6366321

Exercise 2 - Implementing Locks

We have implemented Locks to closely resemble the Semaphore implementation. The primary distinction
is in the internal value it holds, which is always initialized to 1. This ensures that only 1
thread can acquire the Lock at any given time. This Lock also keeps track of the thread that acquired
it, and only that specific thread can release it. For testing purposes, we substituted
Semaphores with Locks as in the same SimpleThread() function. The results remained same with the
previous implementation. As in the Semaphore solution, the critical section is entered with an Acquire() 
call and exited with a Release() call.

Exercise 3 - Implementing Conditions

The conditions are implemented in a similar way to semaphores and locks. However, a key difference
is that conditions do not internally check a value during their function calls. Instead, they maintain
the list of threads that are waiting on the condition. waiting here means the threads are
placed in a blocked state using a sleep() call.

The Wait() function is responsible for this action, under the assumption that the lock passed into it
has been acquired by the calling thread. Before going to sleep, the thread releases the lock, allowing
other threads to use it. Subsequently, when another thread executes a Signal() or Broadcast() function,
a thread that was waiting on the condition will wake up and attempt to re-acquire the lock. The Signal()
function awakens a single thread that is waiting on the condition, while the Broadcast() function awakens 
all threads in the waiting state for that condition. It's essential to note that these functions can only 
execute successfully if the calling thread has acquired the Lock passed to them.
