Project 1 Report for Group 7

Exercise 1 - Dillon Archer 6224872

For the first part of this exercise, I modified Threadtest1() to take n number of integers by 
implementing a for loop. This allowed the function to fork 'n' number of Threads 
which call SimpleThread(). Next, I modified SimpleThread to share a variable called
SharedVariable between all of the forked and original threads. Once the for loop within
SimpleThread is completed, SharedVariable is stored within val and displayed using a printf statment
to show what value each thread sees within the function call. 

Before the implementation of the semaphores, when the for loop runs, each thread would overwrite
the increment done by the previous thread on the global variable when it yields the processor 
to the next thread. This resulted in a situation where in a case when there is 'n' 
number of threads, the global variable would contain a value that is 'n/5'.

After implementing the semaphores, the global variable is properly synchronized across all threads.
First, the Semaphore value is incremented by one at the start of the ThreadTest1 function to indicate
that the processor is available to be utilized by the threads. Then, as each thread runs its for loop,
it acquires the processor by calling the Semaphore s.P() function. Once it is done updating the local, 
variable, the thread releases the processor by incrementing the value of the semaphore. If a processor
happens to acquire the processor before the semaphore is released, then the current thread is put
to sleep by the semaphore before it is allowed to increment the global variable.  


Nagarjun Tumkur Sharathkumar - 6366321

Exercise 2 - Implementing Locks

We have implemented Locks to closely resemble the Semaphore implementation. The primary distinction
is in the internal value it holds, which is always initialized to 1. This ensures that only 1
thread can acquire the Lock at any given time. This Lock also keeps track of the thread that acquired
it, and only that specific thread can release it. For testing purposes, we substituted
Semaphores with Locks as in the same SimpleThread() function. The results remained same with the
previous implementation. As in the Semaphore solution, the critical section is entered with an Acquire() 
call and exited with a Release() call.

Exercise 3 - Implementing Conditions

The conditions are implemented in a similar way to semaphores and locks. However, a key difference
is that conditions do not internally check a value during their function calls. Instead, they maintain
the list of threads that are waiting on the condition. waiting here means the threads are
placed in a blocked state using a sleep() call.

The Wait() function is responsible for this action, under the assumption that the lock passed into it
has been acquired by the calling thread. Before going to sleep, the thread releases the lock, allowing
other threads to use it. Subsequently, when another thread executes a Signal() or Broadcast() function,
a thread that was waiting on the condition will wake up and attempt to re-acquire the lock. The Signal()
function awakens a single thread that is waiting on the condition, while the Broadcast() function awakens 
all threads in the waiting state for that condition. It's essential to note that these functions can only 
execute successfully if the calling thread has acquired the Lock passed to them.

Exercise 4 - Anne Nguyen 5643071

For this part of the exercise, I implemented the Elevator and ArrivingGoingFromTo functions. 
I chose to use semaphores to maintain the synchronization of the threads.
There were several points in which I believe that I started overthinking the project. In the end, 
I first implemented the two structures to store the data that is needed for the functions to run.
Then I started with the simpler function Elevator as it would only be called once. There, I 
specifically made a loop to awaken the semaphore 5 times so it could be used to track the
max number of people who could fit in the elevator at once. Using that method, it would also naturally 
block any more requests from boarding the elevator until the semaphore has released at least 1 more count.
The harder part was the implementation of the ArrivingGoingFromTo function. 
I could not justify awakening the elevator function within this function with awakening the semaphore because the
Elevator function specifically called for a parameter that ArrivingGoingFromTo doesn't have. Going off
of what I understand about semaphores, as long as the counting semaphore has more than 0 as it's value, then the elevator
function is active. 
To generate the ID, I originally thought about using a random number generator but decided not to on account of possible
non-thread-safe issues. Instead, I decided to use a mix of numbers relevant to the elevator requestor in combination
with information that I have from the structs to create the numbers.
When it came to the more active elevator call segment, I needed to essentially loop-checking floors for incoming request.
While I originally started with the correct floor where the elevator is above the while loops, I shifted it to under the while loops because
it works better that way for the purposes of this project. 
During the loops, I had to keep on checking whether there were more threads being generated so every floor, the thread would attempt to yield to 
a request that is on the nearest floor, mostly due to how I use the floor difference variables. The smaller the floor difference, the faster a thread 
would reach the yield command.
There was only 1 main critical section in this code, where the people boarded the elevator.
There was an issue getting the implementation to work correctly in that the counting semaphore implementation did not work successfully.
